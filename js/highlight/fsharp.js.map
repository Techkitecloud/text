{"version":3,"sources":["webpack:///text/node_modules/highlight.js/lib/languages/fsharp.js"],"names":["source","re","lookahead","concat","args","map","x","join","either","opts","length","constructor","Object","splice","stripOptionsFromArgs","capture","module","exports","hljs","BANG_KEYWORD_MODE","scope","match","ALL_KEYWORDS","type","keyword","literal","built_in","COMMENT","variants","contains","C_LINE_COMMENT_MODE","GENERIC_TYPE_SYMBOL","UNDERSCORE_IDENT_RE","relevance","COMPUTATION_EXPRESSION","PREPROCESSOR","begin","beginScope","end","NUMBER","BINARY_NUMBER_MODE","C_NUMBER_MODE","QUOTED_STRING","BACKSLASH_ESCAPE","VERBATIM_STRING","SUBST","keywords","INTERPOLATED_STRING","INTERPOLATED_VERBATIM_STRING","INTERPOLATED_TRIPLE_QUOTED_STRING","CHAR_LITERAL","name","aliases","illegal","classNameAliases","excludeBegin"],"mappings":"wFASA,SAASA,EAAOC,GACd,OAAKA,EACa,iBAAPA,EAAwBA,EAE5BA,EAAGD,OAHM,KAUlB,SAASE,EAAUD,GACjB,OAAOE,EAAO,MAAOF,EAAI,KAO3B,SAASE,KAAUC,GAEjB,OADeA,EAAKC,KAAKC,GAAMN,EAAOM,KAAIC,KAAK,IA0BjD,SAASC,KAAUJ,GAMjB,MAHe,KArBjB,SAA8BA,GAC5B,MAAMK,EAAOL,EAAKA,EAAKM,OAAS,GAEhC,MAAoB,iBAATD,GAAqBA,EAAKE,cAAgBC,QACnDR,EAAKS,OAAOT,EAAKM,OAAS,EAAG,GACtBD,GAEA,GAaIK,CAAqBV,GAExBW,QAAU,GAAK,MACrBX,EAAKC,KAAKC,GAAMN,EAAOM,KAAIC,KAAK,KAAO,IAyb7CS,EAAOC,QA5aP,SAAgBC,GACd,MAmEMC,EAAoB,CAExBC,MAAO,UACPC,MAAO,sCAwHHC,EAAe,CACnBC,KAlFY,CAEZ,OACA,OACA,QACA,OACA,QACA,QACA,QACA,SACA,SACA,MACA,OACA,QACA,SACA,YACA,aACA,UACA,QACA,SACA,UACA,SACA,OACA,SACA,OACA,SAEA,SACA,UACA,OACA,QACA,MACA,QACA,MACA,QACA,YACA,MACA,SACA,WA6CAC,QAhMe,CACf,WACA,MACA,KACA,SACA,OACA,QACA,QACA,UACA,WACA,KACA,OACA,WACA,SACA,OACA,OACA,MACA,YACA,SAEA,UACA,QACA,MACA,MACA,WACA,SACA,KACA,KACA,UACA,SACA,YACA,WACA,OACA,MACA,QACA,SACA,SACA,UACA,YACA,MAGA,KACA,OACA,KACA,WACA,UACA,SACA,MACA,SACA,SACA,SACA,OACA,KAEA,MACA,OACA,SACA,MACA,MACA,OACA,OACA,QACA,OACA,SAiIAC,QAxGe,CACf,OACA,QACA,OACA,OACA,OACA,KACA,QACA,WACA,YACA,MACA,QA8FAC,SA5Ce,CAKf,MACA,MACA,QACA,UACA,OACA,eACA,MACA,OACA,SACA,SACA,YACA,SACA,UACA,aACA,YACA,KACA,MACA,MACA,SACA,OACA,QACA,MACA,QACA,WACA,SACA,UACA,UACA,UACA,WACA,UACA,WACA,WACA,aAQA,oBA5F0B,CAC1B,WACA,uBACA,oBAkGIC,EAAU,CACdC,SAAU,CALVV,EAAKS,QAAQ,aAAc,OAAQ,CACjCE,SAAU,CAAC,UAMXX,EAAKY,sBAKHC,EAAsB,CAC1BV,MAAOlB,EAAO,SAAUe,EAAKc,qBAC7BZ,MAAO,SACPa,UAAW,GAGPC,EAAyB,CAE7Bd,MAAO,yBACPC,MAAO,wBAGHc,EAAe,CAEnBC,MAAO,CACL,OACAjC,EAAO,IAAKK,EA1Jd,KACA,OACA,QACA,OACA,SACA,QACA,IACA,IACA,IACA,OACA,OACA,OACA,SA+IE,MAEF6B,WAAY,CAAE,EAAG,QACjBC,IAAKpC,EAAU,SAKXqC,EAAS,CACbX,SAAU,CACRV,EAAKsB,mBACLtB,EAAKuB,gBAQHC,EAAgB,CACpBtB,MAAO,SACPgB,MAAO,IACPE,IAAK,IACLT,SAAU,CACRX,EAAKyB,mBAIHC,EAAkB,CACtBxB,MAAO,SACPgB,MAAO,KACPE,IAAK,IACLT,SAAU,CACR,CACER,MAAO,MAETH,EAAKyB,mBAUHE,EAAQ,CACZzB,MAAO,QACPgB,MAAO,KACPE,IAAK,KACLQ,SAAUxB,GAGNyB,EAAsB,CAC1B3B,MAAO,SACPgB,MAAO,MACPE,IAAK,IACLT,SAAU,CACR,CACER,MAAO,QAET,CACEA,MAAO,QAETH,EAAKyB,iBACLE,IAIEG,EAA+B,CACnC5B,MAAO,SACPgB,MAAO,aACPE,IAAK,IACLT,SAAU,CACR,CACER,MAAO,QAET,CACEA,MAAO,QAET,CACEA,MAAO,MAETH,EAAKyB,iBACLE,IAIEI,EAAoC,CACxC7B,MAAO,SACPgB,MAAO,QACPE,IAAK,MACLT,SAAU,CACR,CACER,MAAO,QAET,CACEA,MAAO,QAETwB,GAEFZ,UAAW,GAGPiB,EAAe,CACnB9B,MAAO,SACPC,MAAOlB,EACL,IACAK,EACE,SACA,8DAEF,MA+BJ,OAzBAqC,EAAMhB,SAAW,CACfmB,EACAD,EACAH,EACAF,EACAQ,EACA/B,EACAQ,EACAO,EACAC,EACAI,EACAR,GAcK,CACLoB,KAAM,KACNC,QAAS,CACP,KACA,MAEFN,SAAUxB,EACV+B,QAAS,OACTC,iBAAkB,CAChB,yBAA0B,WAE5BzB,SAAU,CACRV,EAxBW,CACbS,SAAU,CACRqB,EACAD,EACAD,EA/FyB,CAC3B3B,MAAO,SACPgB,MAAO,MACPE,IAAK,MACLL,UAAW,GA6FTW,EACAF,EACAQ,IAkBAvB,EACA,CAEES,MAAO,CACL,OACA,MACAlB,EAAKc,qBAEPK,WAAY,CACV,EAAG,UACH,EAAG,eAELC,IAAKpC,EAAU,UACf2B,SAAU,CACRE,IAGJ,CAEEX,MAAO,OACPgB,MAAO,UACPmB,cAAc,EACdjB,IAAKpC,EAAU,OACf+B,UAAW,EACXJ,SAAU,CACR,CACET,MAAO,SACPgB,MAAO,IACPE,IAAK,KAEPC,IAGJL,EACAC,EACAI,EACAR","file":"highlight/fsharp.js?v=a0f347a0adb5f774e8ae","sourcesContent":["/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\n/**\n * @param { Array<string | RegExp | Object> } args\n * @returns {object}\n */\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  /** @type { object & {capture?: boolean} }  */\n  const opts = stripOptionsFromArgs(args);\n  const joined = '('\n    + (opts.capture ? \"\" : \"?:\")\n    + args.map((x) => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\n/*\nLanguage: F#\nAuthor: Jonas Follesø <jonas@follesoe.no>\nContributors: Troy Kershaw <hello@troykershaw.com>, Henrik Feldt <henrik@haf.se>, Melvyn Laïly <melvyn.laily@gmail.com>\nWebsite: https://docs.microsoft.com/en-us/dotnet/fsharp/\nCategory: functional\n*/\n\n/** @type LanguageFn */\nfunction fsharp(hljs) {\n  const KEYWORDS = [\n    \"abstract\",\n    \"and\",\n    \"as\",\n    \"assert\",\n    \"base\",\n    \"begin\",\n    \"class\",\n    \"default\",\n    \"delegate\",\n    \"do\",\n    \"done\",\n    \"downcast\",\n    \"downto\",\n    \"elif\",\n    \"else\",\n    \"end\",\n    \"exception\",\n    \"extern\",\n    // \"false\", // literal\n    \"finally\",\n    \"fixed\",\n    \"for\",\n    \"fun\",\n    \"function\",\n    \"global\",\n    \"if\",\n    \"in\",\n    \"inherit\",\n    \"inline\",\n    \"interface\",\n    \"internal\",\n    \"lazy\",\n    \"let\",\n    \"match\",\n    \"member\",\n    \"module\",\n    \"mutable\",\n    \"namespace\",\n    \"new\",\n    // \"not\", // built_in\n    // \"null\", // literal\n    \"of\",\n    \"open\",\n    \"or\",\n    \"override\",\n    \"private\",\n    \"public\",\n    \"rec\",\n    \"return\",\n    \"static\",\n    \"struct\",\n    \"then\",\n    \"to\",\n    // \"true\", // literal\n    \"try\",\n    \"type\",\n    \"upcast\",\n    \"use\",\n    \"val\",\n    \"void\",\n    \"when\",\n    \"while\",\n    \"with\",\n    \"yield\"\n  ];\n\n  const BANG_KEYWORD_MODE = {\n    // monad builder keywords (matches before non-bang keywords)\n    scope: 'keyword',\n    match: /\\b(yield|return|let|do|match|use)!/\n  };\n\n  const PREPROCESSOR_KEYWORDS = [\n    \"if\",\n    \"else\",\n    \"endif\",\n    \"line\",\n    \"nowarn\",\n    \"light\",\n    \"r\",\n    \"i\",\n    \"I\",\n    \"load\",\n    \"time\",\n    \"help\",\n    \"quit\"\n  ];\n\n  const LITERALS = [\n    \"true\",\n    \"false\",\n    \"null\",\n    \"Some\",\n    \"None\",\n    \"Ok\",\n    \"Error\",\n    \"infinity\",\n    \"infinityf\",\n    \"nan\",\n    \"nanf\"\n  ];\n\n  const SPECIAL_IDENTIFIERS = [\n    \"__LINE__\",\n    \"__SOURCE_DIRECTORY__\",\n    \"__SOURCE_FILE__\"\n  ];\n\n  const TYPES = [\n    // basic types\n    \"bool\",\n    \"byte\",\n    \"sbyte\",\n    \"int8\",\n    \"int16\",\n    \"int32\",\n    \"uint8\",\n    \"uint16\",\n    \"uint32\",\n    \"int\",\n    \"uint\",\n    \"int64\",\n    \"uint64\",\n    \"nativeint\",\n    \"unativeint\",\n    \"decimal\",\n    \"float\",\n    \"double\",\n    \"float32\",\n    \"single\",\n    \"char\",\n    \"string\",\n    \"unit\",\n    \"bigint\",\n    // other native types or lowercase aliases\n    \"option\",\n    \"voption\",\n    \"list\",\n    \"array\",\n    \"seq\",\n    \"byref\",\n    \"exn\",\n    \"inref\",\n    \"nativeptr\",\n    \"obj\",\n    \"outref\",\n    \"voidptr\"\n  ];\n\n  const BUILTINS = [\n    // Somewhat arbitrary list of builtin functions and values.\n    // Most of them are declared in Microsoft.FSharp.Core\n    // I tried to stay relevant by adding only the most idiomatic\n    // and most used symbols that are not already declared as types.\n    \"not\",\n    \"ref\",\n    \"raise\",\n    \"reraise\",\n    \"dict\",\n    \"readOnlyDict\",\n    \"set\",\n    \"enum\",\n    \"sizeof\",\n    \"typeof\",\n    \"typedefof\",\n    \"nameof\",\n    \"nullArg\",\n    \"invalidArg\",\n    \"invalidOp\",\n    \"id\",\n    \"fst\",\n    \"snd\",\n    \"ignore\",\n    \"lock\",\n    \"using\",\n    \"box\",\n    \"unbox\",\n    \"tryUnbox\",\n    \"printf\",\n    \"printfn\",\n    \"sprintf\",\n    \"eprintf\",\n    \"eprintfn\",\n    \"fprintf\",\n    \"fprintfn\",\n    \"failwith\",\n    \"failwithf\"\n  ];\n\n  const ALL_KEYWORDS = {\n    type: TYPES,\n    keyword: KEYWORDS,\n    literal: LITERALS,\n    built_in: BUILTINS,\n    'variable.constant': SPECIAL_IDENTIFIERS\n  };\n\n  // (* potentially multi-line Meta Language style comment *)\n  const ML_COMMENT =\n    hljs.COMMENT(/\\(\\*(?!\\))/, /\\*\\)/, {\n      contains: [\"self\"]\n    });\n  // Either a multi-line (* Meta Language style comment *) or a single line // C style comment.\n  const COMMENT = {\n    variants: [\n      ML_COMMENT,\n      hljs.C_LINE_COMMENT_MODE,\n    ]\n  };\n\n  // 'a or ^a\n  const GENERIC_TYPE_SYMBOL = {\n    match: concat(/('|\\^)/, hljs.UNDERSCORE_IDENT_RE),\n    scope: 'symbol',\n    relevance: 0\n  };\n\n  const COMPUTATION_EXPRESSION = {\n    // computation expressions:\n    scope: 'computation-expression',\n    match: /\\b[_a-z]\\w*(?=\\s*\\{)/\n  };\n\n  const PREPROCESSOR = {\n    // preprocessor directives and fsi commands:\n    begin: [\n      /^\\s*/,\n      concat(/#/, either(...PREPROCESSOR_KEYWORDS)),\n      /\\b/\n    ],\n    beginScope: { 2: 'meta' },\n    end: lookahead(/\\s|$/)\n  };\n\n  // TODO: this definition is missing support for type suffixes and octal notation.\n  // BUG: range operator without any space is wrongly interpreted as a single number (e.g. 1..10 )\n  const NUMBER = {\n    variants: [\n      hljs.BINARY_NUMBER_MODE,\n      hljs.C_NUMBER_MODE\n    ]\n  };\n\n  // All the following string definitions are potentially multi-line.\n  // BUG: these definitions are missing support for byte strings (suffixed with B)\n\n  // \"...\"\n  const QUOTED_STRING = {\n    scope: 'string',\n    begin: /\"/,\n    end: /\"/,\n    contains: [\n      hljs.BACKSLASH_ESCAPE\n    ]\n  };\n  // @\"...\"\n  const VERBATIM_STRING = {\n    scope: 'string',\n    begin: /@\"/,\n    end: /\"/,\n    contains: [\n      {\n        match: /\"\"/ // escaped \"\n      },\n      hljs.BACKSLASH_ESCAPE\n    ]\n  };\n  // \"\"\"...\"\"\"\n  const TRIPLE_QUOTED_STRING = {\n    scope: 'string',\n    begin: /\"\"\"/,\n    end: /\"\"\"/,\n    relevance: 2\n  };\n  const SUBST = {\n    scope: 'subst',\n    begin: /\\{/,\n    end: /\\}/,\n    keywords: ALL_KEYWORDS\n  };\n  // $\"...{1+1}...\"\n  const INTERPOLATED_STRING = {\n    scope: 'string',\n    begin: /\\$\"/,\n    end: /\"/,\n    contains: [\n      {\n        match: /\\{\\{/ // escaped {\n      },\n      {\n        match: /\\}\\}/ // escaped }\n      },\n      hljs.BACKSLASH_ESCAPE,\n      SUBST\n    ]\n  };\n  // $@\"...{1+1}...\"\n  const INTERPOLATED_VERBATIM_STRING = {\n    scope: 'string',\n    begin: /(\\$@|@\\$)\"/,\n    end: /\"/,\n    contains: [\n      {\n        match: /\\{\\{/ // escaped {\n      },\n      {\n        match: /\\}\\}/ // escaped }\n      },\n      {\n        match: /\"\"/\n      },\n      hljs.BACKSLASH_ESCAPE,\n      SUBST\n    ]\n  };\n  // $\"\"\"...{1+1}...\"\"\"\n  const INTERPOLATED_TRIPLE_QUOTED_STRING = {\n    scope: 'string',\n    begin: /\\$\"\"\"/,\n    end: /\"\"\"/,\n    contains: [\n      {\n        match: /\\{\\{/ // escaped {\n      },\n      {\n        match: /\\}\\}/ // escaped }\n      },\n      SUBST\n    ],\n    relevance: 2\n  };\n  // '.'\n  const CHAR_LITERAL = {\n    scope: 'string',\n    match: concat(\n      /'/,\n      either(\n        /[^\\\\']/, // either a single non escaped char...\n        /\\\\(?:.|\\d{3}|x[a-fA-F\\d]{2}|u[a-fA-F\\d]{4}|U[a-fA-F\\d]{8})/ // ...or an escape sequence\n      ),\n      /'/\n    )\n  };\n  // F# allows a lot of things inside string placeholders.\n  // Things that don't currently seem allowed by the compiler: types definition, attributes usage.\n  // (Strictly speaking, some of the followings are only allowed inside triple quoted interpolated strings...)\n  SUBST.contains = [\n    INTERPOLATED_VERBATIM_STRING,\n    INTERPOLATED_STRING,\n    VERBATIM_STRING,\n    QUOTED_STRING,\n    CHAR_LITERAL,\n    BANG_KEYWORD_MODE,\n    COMMENT,\n    COMPUTATION_EXPRESSION,\n    PREPROCESSOR,\n    NUMBER,\n    GENERIC_TYPE_SYMBOL\n  ];\n  const STRING = {\n    variants: [\n      INTERPOLATED_TRIPLE_QUOTED_STRING,\n      INTERPOLATED_VERBATIM_STRING,\n      INTERPOLATED_STRING,\n      TRIPLE_QUOTED_STRING,\n      VERBATIM_STRING,\n      QUOTED_STRING,\n      CHAR_LITERAL\n    ]\n  };\n\n  return {\n    name: 'F#',\n    aliases: [\n      'fs',\n      'f#'\n    ],\n    keywords: ALL_KEYWORDS,\n    illegal: /\\/\\*/,\n    classNameAliases: {\n      'computation-expression': 'keyword'\n    },\n    contains: [\n      BANG_KEYWORD_MODE,\n      STRING,\n      COMMENT,\n      {\n        // type MyType<'a> = ...\n        begin: [\n          /type/,\n          /\\s+/,\n          hljs.UNDERSCORE_IDENT_RE\n        ],\n        beginScope: {\n          1: 'keyword',\n          3: 'title.class'\n        },\n        end: lookahead(/\\(|=|$/),\n        contains: [\n          GENERIC_TYPE_SYMBOL\n        ]\n      },\n      {\n        // [<Attributes(\"\")>]\n        scope: 'meta',\n        begin: /^\\s*\\[</,\n        excludeBegin: true,\n        end: lookahead(/>\\]/),\n        relevance: 2,\n        contains: [\n          {\n            scope: 'string',\n            begin: /\"/,\n            end: /\"/\n          },\n          NUMBER\n        ]\n      },\n      COMPUTATION_EXPRESSION,\n      PREPROCESSOR,\n      NUMBER,\n      GENERIC_TYPE_SYMBOL\n    ]\n  };\n}\n\nmodule.exports = fsharp;\n"],"sourceRoot":""}